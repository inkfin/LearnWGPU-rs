[
  {
    "objectID": "slides/introduction.html#what-is-webgpu",
    "href": "slides/introduction.html#what-is-webgpu",
    "title": "WGPU with Rust in 50min",
    "section": "What is WebGPU?",
    "text": "What is WebGPU?\n\nWebGPU is the next generation of WebGL and a cross-platform API.\nBackends: browser webgpu, vulkan, DX12, metal…\nImplementations\n\nwgpu for rust\nwgpu-native for c++\ngoogle dawn implementation in chromium\n\n\n\n\n\n\n\n\n\n\n\nFigure 1: wgpu github page\n\n\n\n\n\n\n\n\n\n\n\nFigure 2: wgpu-native github page\n\n\n\n\n\n\n\n\nmore universal\nmultiple backends, including Vulkan, webgpu",
    "crumbs": [
      "Slides",
      "WGPU with Rust in 50min"
    ]
  },
  {
    "objectID": "slides/introduction.html#meet-rust",
    "href": "slides/introduction.html#meet-rust",
    "title": "WGPU with Rust in 50min",
    "section": "Meet Rust ",
    "text": "Meet Rust \n\nRust is a modern programming language that balances high-level ergonomics and low-level control. 1\n\nmemory safety\nzero-cost abstraction\npowerful toolsets\n\n\nThe book: https://doc.rust-lang.org/book/",
    "crumbs": [
      "Slides",
      "WGPU with Rust in 50min"
    ]
  },
  {
    "objectID": "slides/introduction.html#to-get-started",
    "href": "slides/introduction.html#to-get-started",
    "title": "WGPU with Rust in 50min",
    "section": "To get started",
    "text": "To get started\n\nInstall rustup (Instructions)\n\nrustc --version\n# will gives you something like: \n#   rustc 1.75.0 (82e1608df 2023-12-21)\n\nCargo is the rust’s official package manager\n\n# cd into the project root directory\ncargo run --release\n\nInstall wasm-pack (Instructions)\n\nwasm-pack build --target web",
    "crumbs": [
      "Slides",
      "WGPU with Rust in 50min"
    ]
  },
  {
    "objectID": "slides/introduction.html#comparing-to-opengl-c",
    "href": "slides/introduction.html#comparing-to-opengl-c",
    "title": "WGPU with Rust in 50min",
    "section": "Comparing to OpenGL & C++…",
    "text": "Comparing to OpenGL & C++…\n\n\nC++\n\nmore flexible with raw pointer\nuse a lot of classes, interfaces\nthe language of lots of game engines: Source, Unreal Engine\nglew + glfw + imgui\n\n\nRust\n\nbetter error handle & easier async\nno Class, use struct & traits\nnew experimental game engines under development: Bevy, Fyrox\nwgpu + winit + egui",
    "crumbs": [
      "Slides",
      "WGPU with Rust in 50min"
    ]
  },
  {
    "objectID": "slides/introduction.html#hello-world",
    "href": "slides/introduction.html#hello-world",
    "title": "WGPU with Rust in 50min",
    "section": "Hello world!",
    "text": "Hello world!\nFirst, create a rust project using cargo\ncargo new hello-world\nUse your favorite editor and edit the src/main.rs:\nfn main() {\n    let name = \"ink\";\n    println!(\"Hello, world! from {:?}\", name)\n}\nTo run the code:\ncargo run\nThe result should be:\n\n\nHello, world! from \"ink\"",
    "crumbs": [
      "Slides",
      "WGPU with Rust in 50min"
    ]
  },
  {
    "objectID": "slides/introduction.html#great-now-the-wgpu-examples",
    "href": "slides/introduction.html#great-now-the-wgpu-examples",
    "title": "WGPU with Rust in 50min",
    "section": "Great! Now the wgpu examples",
    "text": "Great! Now the wgpu examples\n\nThe example git repository: link\n\n# we do a shallow clone\ngit clone https://github.com/inkfin/LearnWGPU-rs.git --depth=1 \nSee the README.md for build instructions, or you can find the pre-build examples in the DEMO part on my GitHub page.\n\n\nThe official repository example (some of v0.18 examples are broken with current API): wgpu v0.18 examples",
    "crumbs": [
      "Slides",
      "WGPU with Rust in 50min"
    ]
  },
  {
    "objectID": "slides/introduction.html#take-a-sip-of-coffee..",
    "href": "slides/introduction.html#take-a-sip-of-coffee..",
    "title": "WGPU with Rust in 50min",
    "section": "Take a sip of coffee..",
    "text": "Take a sip of coffee..\n\nLet’s take a short break. Feel free to stretch, refill your coffee, and prepare for our next segment on integrating Rust with wgpu.\nHave any questions so far?",
    "crumbs": [
      "Slides",
      "WGPU with Rust in 50min"
    ]
  },
  {
    "objectID": "slides/introduction.html#what-we-have-learned-from-521",
    "href": "slides/introduction.html#what-we-have-learned-from-521",
    "title": "WGPU with Rust in 50min",
    "section": "What we have learned from 521",
    "text": "What we have learned from 521\n\n\nEverything is in a giant state machine\nglCommands depend on context\nObjects are generated and returned as IDs\nNeed to bind objects to the current target before performing any actions\nNo abstraction for render passes and render pipeline\n\nNeed developers to create their own pipeline by setting things in the context",
    "crumbs": [
      "Slides",
      "WGPU with Rust in 50min"
    ]
  },
  {
    "objectID": "slides/introduction.html#wgpu-pipeline-1",
    "href": "slides/introduction.html#wgpu-pipeline-1",
    "title": "WGPU with Rust in 50min",
    "section": "Wgpu pipeline",
    "text": "Wgpu pipeline\n\nBetter abstractions (simillar to vulkan)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nInstance\n\n\n\nSurface\n\n\n\nAdapter\n\n\n\nDevice\n\n\n\nQueue\n\n\n\n\n\n\n\n\n\n\nInstance: a handle to our GPU, first thing ever created ([GPU] in WebGPU)\nSurface: a platform-specific surface (e.g., a window) onto which rendered images may be presented ([GPUCanvasContext] in WebGPU)\n\nCareful: need to live as long as the window (canvas)\n\nAdapter: Handle to a physical graphics and/or compute device ([GPUAdapter] in WebGPU)",
    "crumbs": [
      "Slides",
      "WGPU with Rust in 50min"
    ]
  },
  {
    "objectID": "slides/introduction.html#cont.",
    "href": "slides/introduction.html#cont.",
    "title": "WGPU with Rust in 50min",
    "section": "Cont.",
    "text": "Cont.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nInstance\n\n\n\nSurface\n\n\n\nAdapter\n\n\n\nDevice\n\n\n\nQueue\n\n\n\n\n\n\n\n\n\n\nDevice: Open connection to a graphics and/or compute device. ([GPUDevice] in WebGPU)\n\nResponsible for the creation of most rendering and compute resources. These are then used in commands, which are submitted to a [Queue].\n\nQueue: Handle to a command queue on a device ([GPUQueue] in WebGPU)\n\nexecutes recorded [CommandBuffer] objects and provides convenience methods for writing to buffers and textures.",
    "crumbs": [
      "Slides",
      "WGPU with Rust in 50min"
    ]
  },
  {
    "objectID": "slides/introduction.html#the-structure-of-a-renderpass",
    "href": "slides/introduction.html#the-structure-of-a-renderpass",
    "title": "WGPU with Rust in 50min",
    "section": "The Structure of a RenderPass",
    "text": "The Structure of a RenderPass\n\n\n\n\n\n\n\n\n\nPipelineLayout\n\n\n\nBindgroups\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nset_vertex_buffer\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nset_pipeline\n\n\n\n\n\n\n\n\n\n\n\nUniformBindGroupLayoutTextureBindGroupLayoutStorageBindGroupLayout…\n\n\n\nRenderPipelineLayout\n\n\n\nFragmentState\n\n\n\nFragmentShader\n\n\n\nVertexState\n\n\n\nVertexShader\n\n\n\nVertexBufferLayout\n\n\n\nBindgroup 0Bindgroup 1Bindgroup 2…\n\n\n\nBindGroupLayout\n\n\n\nBuffers\n\n\n\nTexture\n\n\n\nRenderPass\n\n\n\nRenderPipeline",
    "crumbs": [
      "Slides",
      "WGPU with Rust in 50min"
    ]
  },
  {
    "objectID": "slides/introduction.html#renderpass",
    "href": "slides/introduction.html#renderpass",
    "title": "WGPU with Rust in 50min",
    "section": "RenderPass",
    "text": "RenderPass\nThis is the vulkan || webgpu abstraction of rendering procedure.\nEncoder & Renderpass object will return a CommandBuffer, a complete sequence of commands that may be submitted to a command queue\n\n\nBindGroups (maps Buffers & Textures to bind points)\nVertexBufferLayout (VertexAttributes)\nShader",
    "crumbs": [
      "Slides",
      "WGPU with Rust in 50min"
    ]
  },
  {
    "objectID": "slides/introduction.html#renderpass-1",
    "href": "slides/introduction.html#renderpass-1",
    "title": "WGPU with Rust in 50min",
    "section": "RenderPass",
    "text": "RenderPass\nlet mut encoder = device.create_command_encoder(...);\n{\n  // force out of scope since render_pass can't live longer than encoder\n  let mut render_pass = encoder.begin_render_pass(\n    &wgpu::RenderPassDescriptor {\n      label: Some(\"Render Pass\"),\n      color_attachments: ...,\n      depth_stencil_attachment: ...,\n      occlusion_query_set: None,\n      timestamp_writes: None,\n  });\n  render_pass.set_pipeline(...);\n  render_pass.set_vertex_buffer(...);\n  render_pass.set_index_buffer(...);\n  render_pass.set_bind_group(...);\n  render_pass.draw_indexed();\n}\nqueue.submit(vec![encoder.finish()]);\n\n\nsource code: example_cube/src/lib.rs:481",
    "crumbs": [
      "Slides",
      "WGPU with Rust in 50min"
    ]
  },
  {
    "objectID": "slides/introduction.html#renderpass-2",
    "href": "slides/introduction.html#renderpass-2",
    "title": "WGPU with Rust in 50min",
    "section": "RenderPass",
    "text": "RenderPass\nlet mut encoder = device.create_command_encoder(...);\n{\n  // force out of scope since render_pass can't live longer than encoder\n  let mut render_pass = encoder.begin_render_pass(\n    &wgpu::RenderPassDescriptor {\n      label: Some(\"Render Pass\"),\n      color_attachments: ...,\n      depth_stencil_attachment: ...,\n      occlusion_query_set: None,\n      timestamp_writes: None,\n  });\n  render_pass.set_pipeline(...);\n  render_pass.set_vertex_buffer(...);\n  render_pass.set_index_buffer(...);\n  render_pass.set_bind_group(...);\n  render_pass.draw_indexed();\n}\nqueue.submit(vec![encoder.finish()]);\n\n\nsource code: example_cube/src/lib.rs:481",
    "crumbs": [
      "Slides",
      "WGPU with Rust in 50min"
    ]
  },
  {
    "objectID": "slides/introduction.html#renderpass-3",
    "href": "slides/introduction.html#renderpass-3",
    "title": "WGPU with Rust in 50min",
    "section": "RenderPass",
    "text": "RenderPass\nlet mut encoder = device.create_command_encoder(...);\n{\n  // force out of scope since render_pass can't live longer than encoder\n  let mut render_pass = encoder.begin_render_pass(\n    &wgpu::RenderPassDescriptor {\n      label: Some(\"Render Pass\"),\n      color_attachments: ...,\n      depth_stencil_attachment: ...,\n      occlusion_query_set: None,\n      timestamp_writes: None,\n  });\n  render_pass.set_pipeline(...);\n  render_pass.set_vertex_buffer(...);\n  render_pass.set_index_buffer(...);\n  render_pass.set_bind_group(...);\n  render_pass.draw_indexed();\n}\nqueue.submit(vec![encoder.finish()]);\n\n\nsource code: example_cube/src/lib.rs:481",
    "crumbs": [
      "Slides",
      "WGPU with Rust in 50min"
    ]
  },
  {
    "objectID": "slides/introduction.html#renderpipeline",
    "href": "slides/introduction.html#renderpipeline",
    "title": "WGPU with Rust in 50min",
    "section": "RenderPipeline",
    "text": "RenderPipeline\n\nThe collection of resources and states.\n\nShader\nBuffers (VertexBuffers, UniformBuffers)\nprimitive state\ndepth_stencil\nother things we don’t care about…",
    "crumbs": [
      "Slides",
      "WGPU with Rust in 50min"
    ]
  },
  {
    "objectID": "slides/introduction.html#renderpipeline-1",
    "href": "slides/introduction.html#renderpipeline-1",
    "title": "WGPU with Rust in 50min",
    "section": "RenderPipeline",
    "text": "RenderPipeline\n\nRenderPipelineLayout\n/// A `PipelineLayout` object describes the available binding groups of a pipeline.\n/// It can be created with [`Device::create_pipeline_layout`].\nRenderPipeline\n/// A `RenderPipeline` object represents a graphics pipeline and its stages, bindings, vertex\n/// buffers and targets. It can be created with [`Device::create_render_pipeline`].",
    "crumbs": [
      "Slides",
      "WGPU with Rust in 50min"
    ]
  },
  {
    "objectID": "slides/introduction.html#wgpu-buffers",
    "href": "slides/introduction.html#wgpu-buffers",
    "title": "WGPU with Rust in 50min",
    "section": "Wgpu buffers",
    "text": "Wgpu buffers\n\nBuffer is GPU-accessible buffer 1\n\nBufferSlice: wgpu side buffer util used to set range of buffers\n\nIt uses BufferInitDescriptor for initialization\n\n\n\nsee example_cube/src/lib.rs:275\n[WebGPU GPUBuffer]",
    "crumbs": [
      "Slides",
      "WGPU with Rust in 50min"
    ]
  },
  {
    "objectID": "slides/introduction.html#vertexbuffer",
    "href": "slides/introduction.html#vertexbuffer",
    "title": "WGPU with Rust in 50min",
    "section": "VertexBuffer",
    "text": "VertexBuffer\nCreate a buffer and init with raw data.\nlet vertex_buffer = device.create_buffer_init(\n  &wgpu::util::BufferInitDescriptor {\n    label: Some(\"Vertex Buffer\"),\n    contents: bytemuck::cast_slice(&vertices),\n    usage: wgpu::BufferUsages::VERTEX,\n});\n\ncontents: plain data\nusage: buffer usage",
    "crumbs": [
      "Slides",
      "WGPU with Rust in 50min"
    ]
  },
  {
    "objectID": "slides/introduction.html#vertexbuffer-1",
    "href": "slides/introduction.html#vertexbuffer-1",
    "title": "WGPU with Rust in 50min",
    "section": "VertexBuffer",
    "text": "VertexBuffer\nSet vertex buffer before the draw call in the render pass.\nrender_pass.set_vertex_buffer(slot, vertex_buffer.slice(..));\n\nslot: index in VertexState::buffers\n\n  // in render_pipeline:\n  wgpu::VertexState {\n      module: &shader,\n      entry_point: \"vs_main\",\n      buffers: &[model::ModelVertex::desc(), InstanceRaw::desc()],\n  },\nLayouts and buffers are set separately!\n\nBufferSlice: wgpu rust side buffer slice\n\neasy to use (no starts or offsets)",
    "crumbs": [
      "Slides",
      "WGPU with Rust in 50min"
    ]
  },
  {
    "objectID": "slides/introduction.html#cont.-1",
    "href": "slides/introduction.html#cont.-1",
    "title": "WGPU with Rust in 50min",
    "section": "Cont.",
    "text": "Cont.\n// in desc():\nwgpu::VertexBufferLayout {\n    array_stride: mem::size_of::&lt;ModelVertex&gt;() as wgpu::BufferAddress,\n    step_mode: wgpu::VertexStepMode::Vertex,\n    attributes: &[\n        wgpu::VertexAttribute {\n            format: wgpu::VertexFormat::Float32x3,\n            offset: 0,\n            shader_location: 0,\n        },\n        wgpu::VertexAttribute {\n            format: wgpu::VertexFormat::Float32x2,\n            offset: mem::size_of::&lt;[f32; 3]&gt;() as wgpu::BufferAddress,\n            shader_location: 1,\n        },\n        wgpu::VertexAttribute {\n            format: wgpu::VertexFormat::Float32x3,\n            offset: mem::size_of::&lt;[f32; 5]&gt;() as wgpu::BufferAddress,\n            shader_location: 2,\n        },\n    ],\n}",
    "crumbs": [
      "Slides",
      "WGPU with Rust in 50min"
    ]
  },
  {
    "objectID": "slides/introduction.html#uniform-buffers",
    "href": "slides/introduction.html#uniform-buffers",
    "title": "WGPU with Rust in 50min",
    "section": "Uniform Buffers",
    "text": "Uniform Buffers\n\nData that is uniform in the same render pass\n\nread-only in shader\ncan be updated (frequently) in client code\n\nusage: wgpu::BufferUsages::UNIFORM | wgpu::BufferUsages::COPY_DST,\nComparing to OpenGL: {.c++}   glBufferData(GL_UNIFORM_BUFFER, size, NULL, GL_DYNAMIC_DRAW);",
    "crumbs": [
      "Slides",
      "WGPU with Rust in 50min"
    ]
  },
  {
    "objectID": "slides/introduction.html#cont.-2",
    "href": "slides/introduction.html#cont.-2",
    "title": "WGPU with Rust in 50min",
    "section": "Cont.",
    "text": "Cont.\n\nBindgroupLayout\n\ndefines how shader treats the buffer\n\nwgpu::BindGroupLayoutEntry {\n  binding: 0,\n  visibility: wgpu::ShaderStages::VERTEX,\n  ty: wgpu::BindingType::Buffer {\n      ty: wgpu::BufferBindingType::Uniform,\n      has_dynamic_offset: false,\n      min_binding_size: None,\n  },\n  count: None,\n}\n\n\n\nsource code: example_cube/src/lib.rs:282",
    "crumbs": [
      "Slides",
      "WGPU with Rust in 50min"
    ]
  },
  {
    "objectID": "slides/introduction.html#textures",
    "href": "slides/introduction.html#textures",
    "title": "WGPU with Rust in 50min",
    "section": "Textures",
    "text": "Textures\n\nBindgroupLayout\n\nthe wgpu shader treats Buffers and Textures in the same way – bindgroup\n\nOpenGL: treats sampler*d as a uniform\n\nenable texture unit\nbind texture\ncall glUniform* to set sampler in the shader\n\nWGPU: set bindgroup where TextureView and Sampler are specifies saperately",
    "crumbs": [
      "Slides",
      "WGPU with Rust in 50min"
    ]
  },
  {
    "objectID": "slides/introduction.html#cont.-3",
    "href": "slides/introduction.html#cont.-3",
    "title": "WGPU with Rust in 50min",
    "section": "Cont.",
    "text": "Cont.\nwgpu::BindGroupLayoutDescriptor {\n    entries: &[\n        wgpu::BindGroupLayoutEntry {\n            binding: 0,\n            visibility: wgpu::ShaderStages::FRAGMENT,\n            ty: wgpu::BindingType::Texture {\n                multisampled: false,\n                view_dimension: wgpu::TextureViewDimension::D2,\n                sample_type: wgpu::TextureSampleType::Float { filterable: true },\n            },\n            count: None,\n        },\n        wgpu::BindGroupLayoutEntry {\n            binding: 1,\n            visibility: wgpu::ShaderStages::FRAGMENT,\n            ty: wgpu::BindingType::Sampler(wgpu::SamplerBindingType::Filtering),\n            count: None,\n        },\n    ],\n    label: Some(\"texture_bind_group_layout\"),\n}",
    "crumbs": [
      "Slides",
      "WGPU with Rust in 50min"
    ]
  },
  {
    "objectID": "slides/introduction.html#cont.-4",
    "href": "slides/introduction.html#cont.-4",
    "title": "WGPU with Rust in 50min",
    "section": "Cont.",
    "text": "Cont.\nlet diffuse_bind_group = device.create_bind_group(\n    &wgpu::BindGroupDescriptor {\n        layout: &texture_bind_group_layout,\n        entries: &[\n            wgpu::BindGroupEntry {\n                binding: 0,\n                resource: wgpu::BindingResource::TextureView(\n                    &diffuse_texture.view),\n            },\n            wgpu::BindGroupEntry {\n                binding: 1,\n                resource: wgpu::BindingResource::Sampler(\n                    &diffuse_texture.sampler),\n            },\n        ],\n        label: Some(\"diffuse_bind_group\"),\n});\n\n\nsource code: example_cube/src/lib.rs:208,233",
    "crumbs": [
      "Slides",
      "WGPU with Rust in 50min"
    ]
  },
  {
    "objectID": "slides/introduction.html#bindgroup",
    "href": "slides/introduction.html#bindgroup",
    "title": "WGPU with Rust in 50min",
    "section": "BindGroup",
    "text": "BindGroup\n\nBindGroupLayout\n/// Handle to a binding group layout.\n///\n/// A `BindGroupLayout` is a handle to the GPU-side layout of a binding group. It can be used to\n/// create a [`BindGroupDescriptor`] object, which in turn can be used to create a [`BindGroup`]\n/// object with [`Device::create_bind_group`]. A series of `BindGroupLayout`s can also be used to\n/// create a [`PipelineLayoutDescriptor`], which can be used to create a [`PipelineLayout`].\n///\n/// It can be created with [`Device::create_bind_group_layout`].\n///\n/// Corresponds to [WebGPU `GPUBindGroupLayout`](\n/// https://gpuweb.github.io/gpuweb/#gpubindgrouplayout).",
    "crumbs": [
      "Slides",
      "WGPU with Rust in 50min"
    ]
  },
  {
    "objectID": "slides/introduction.html#bindgroup-1",
    "href": "slides/introduction.html#bindgroup-1",
    "title": "WGPU with Rust in 50min",
    "section": "BindGroup",
    "text": "BindGroup\n\nBindGroup\n/// Handle to a binding group.\n///\n/// A `BindGroup` represents the set of resources bound to the bindings described by a\n/// [`BindGroupLayout`]. It can be created with [`Device::create_bind_group`]. A `BindGroup` can\n/// be bound to a particular [`RenderPass`] with [`RenderPass::set_bind_group`], or to a\n/// [`ComputePass`] with [`ComputePass::set_bind_group`].\n///\n/// Corresponds to [WebGPU `GPUBindGroup`](https://gpuweb.github.io/gpuweb/#gpubindgroup).",
    "crumbs": [
      "Slides",
      "WGPU with Rust in 50min"
    ]
  },
  {
    "objectID": "slides/introduction.html#bindgroup-in-wgsl",
    "href": "slides/introduction.html#bindgroup-in-wgsl",
    "title": "WGPU with Rust in 50min",
    "section": "BindGroup in WGSL",
    "text": "BindGroup in WGSL\n\nUniform\n\nstruct CameraUniform {\n    view_proj: mat4x4&lt;f32&gt;,\n};\n\n@group(1) @binding(0)\nvar&lt;uniform&gt; camera: CameraUniform;\n\nTexture\n\n@group(0) @binding(0)\nvar t_diffuse: texture_2d&lt;f32&gt;;\n@group(0) @binding(1)\nvar s_diffuse: sampler;",
    "crumbs": [
      "Slides",
      "WGPU with Rust in 50min"
    ]
  },
  {
    "objectID": "slides/introduction.html#yes-you-dont-need-to-learn-wgsl",
    "href": "slides/introduction.html#yes-you-dont-need-to-learn-wgsl",
    "title": "WGPU with Rust in 50min",
    "section": "Yes, you don’t need to learn WGSL!",
    "text": "Yes, you don’t need to learn WGSL!\nThanks to Naga\n\n\n\nYou only need to learn WGSL",
    "crumbs": [
      "Slides",
      "WGPU with Rust in 50min"
    ]
  },
  {
    "objectID": "slides/introduction.html#support-languages",
    "href": "slides/introduction.html#support-languages",
    "title": "WGPU with Rust in 50min",
    "section": "Support languages",
    "text": "Support languages\n\nSPIR-V first class support\nHLSL good support\nGLSL has many limitations\n\nuniform sampler2D mySampler;\nuniform texture2D myTexture;\n\n@group(0) @binding(0) var mySampler: sampler;\n@group(0) @binding(1) var myTexture: texture_2d&lt;f32&gt;;\n\n\ncurrent support: https://github.com/gfx-rs/wgpu/tree/trunk/naga#supported-end-points",
    "crumbs": [
      "Slides",
      "WGPU with Rust in 50min"
    ]
  },
  {
    "objectID": "slides/introduction.html#wgsl-simple-example",
    "href": "slides/introduction.html#wgsl-simple-example",
    "title": "WGPU with Rust in 50min",
    "section": "WGSL simple example 1",
    "text": "WGSL simple example 1\nstruct VertexOutput {\n    @builtin(position) clip_position: vec4&lt;f32&gt;,\n};\n\n@vertex\nfn vs_main(\n    @builtin(vertex_index) in_vertex_index: u32,\n) -&gt; VertexOutput {\n    var out: VertexOutput;\n    let x = f32(1 - i32(in_vertex_index)) * 0.5;\n    let y = f32(i32(in_vertex_index & 1u) * 2 - 1) * 0.5;\n    out.clip_position = vec4&lt;f32&gt;(x, y, 0.0, 1.0);\n    return out;\n}\n\n@fragment\nfn fs_main(in: VertexOutput) -&gt; @location(0) vec4&lt;f32&gt; {\n    return vec4&lt;f32&gt;(0.3, 0.2, 0.1, 1.0);\n}\nlearn-wgpu: tutorial3",
    "crumbs": [
      "Slides",
      "WGPU with Rust in 50min"
    ]
  },
  {
    "objectID": "slides/introduction.html#structure-of-compute-pass",
    "href": "slides/introduction.html#structure-of-compute-pass",
    "title": "WGPU with Rust in 50min",
    "section": "Structure of Compute Pass",
    "text": "Structure of Compute Pass\n\n\n\n\n\n\n\n\n\nBindgroups\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nset_bindgroup\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nset_pipeline\n\n\n\nBindgroup 0Bindgroup 1Bindgroup 2…\n\n\n\nBindGroupLayout\n\n\n\nBuffers\n\n\n\nTexture\n\n\n\nBindGroupLayouts\n\n\n\nPipelineLayout\n\n\n\nComputePass\n\n\n\nComputePipeline\n\n\n\nShader",
    "crumbs": [
      "Slides",
      "WGPU with Rust in 50min"
    ]
  },
  {
    "objectID": "slides/introduction.html#compute-pass",
    "href": "slides/introduction.html#compute-pass",
    "title": "WGPU with Rust in 50min",
    "section": "Compute Pass",
    "text": "Compute Pass\n\nNumber of cells to run, the (x,y,z) size of item being processed\n\ncompute_pass.dispatch_workgroups(numbers.len() as u32, 1, 1);\n\nin each cell:\n\n@compute\n@workgroup_size(2, 1, 1)\nfn main(\n  @builtin(local_invocation_id) lid: vec3&lt;u32&gt;, \n  @builtin(workgroup_id) wid: vec3&lt;u32&gt;\n  ) {\n    if lid.x == 0u {\n        a[wid.x] += 1;\n    } else if lid.x == 1u {\n        b[wid.x] += 1;\n    }\n}",
    "crumbs": [
      "Slides",
      "WGPU with Rust in 50min"
    ]
  },
  {
    "objectID": "slides/introduction.html#compute-shader-in-wgsl",
    "href": "slides/introduction.html#compute-shader-in-wgsl",
    "title": "WGPU with Rust in 50min",
    "section": "Compute Shader in WGSL",
    "text": "Compute Shader in WGSL\nWorkgroups\n@builtin(workgroup_id)            workgroup_id : vec3&lt;u32&gt;,\n@builtin(local_invocation_id)     local_invocation_id : vec3&lt;u32&gt;,\n@builtin(global_invocation_id)    global_invocation_id : vec3&lt;u32&gt;,\n@builtin(local_invocation_index)  local_invocation_index: u32,\n@builtin(num_workgroups)          num_workgroups: vec3&lt;u32&gt;\nStorage buffers\n@group(0) @binding(0) var&lt;storage, read_write&gt; v_indices: array&lt;u32&gt;;\n@group(1) @binding(0) var texture: texture_storage_2d&lt;rgba8unorm, write&gt;;\n// in fn main():\ntextureStore(texture, location, value);\n\n\nwgpu v0.18 workgroup examples\nWebGPU Compute Shader Basics",
    "crumbs": [
      "Slides",
      "WGPU with Rust in 50min"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Home",
    "section": "",
    "text": "This is the home directory of 521-rs project.",
    "crumbs": [
      "Home"
    ]
  },
  {
    "objectID": "slides/intro.html",
    "href": "slides/intro.html",
    "title": "wgpu with rust",
    "section": "",
    "text": "40 pages\n\n\nWGPU is an implementation of WebGPU &gt; 5min\n\n\n\n\n10min\n\n\n\n\n\n5min\n\n\n\n\nbuffers, stuff with example code &gt; 20min\n\n\n\n\n10min",
    "crumbs": [
      "Slides",
      "wgpu with rust"
    ]
  },
  {
    "objectID": "slides/intro.html#what-is-wgpu",
    "href": "slides/intro.html#what-is-wgpu",
    "title": "wgpu with rust",
    "section": "",
    "text": "WGPU is an implementation of WebGPU &gt; 5min",
    "crumbs": [
      "Slides",
      "wgpu with rust"
    ]
  },
  {
    "objectID": "slides/intro.html#rust-in-10min",
    "href": "slides/intro.html#rust-in-10min",
    "title": "wgpu with rust",
    "section": "",
    "text": "10min",
    "crumbs": [
      "Slides",
      "wgpu with rust"
    ]
  },
  {
    "objectID": "slides/intro.html#an-easy-wgsl-example",
    "href": "slides/intro.html#an-easy-wgsl-example",
    "title": "wgpu with rust",
    "section": "",
    "text": "5min",
    "crumbs": [
      "Slides",
      "wgpu with rust"
    ]
  },
  {
    "objectID": "slides/intro.html#wgpu-pipeline",
    "href": "slides/intro.html#wgpu-pipeline",
    "title": "wgpu with rust",
    "section": "",
    "text": "buffers, stuff with example code &gt; 20min",
    "crumbs": [
      "Slides",
      "wgpu with rust"
    ]
  },
  {
    "objectID": "slides/intro.html#example-demonstration",
    "href": "slides/intro.html#example-demonstration",
    "title": "wgpu with rust",
    "section": "",
    "text": "10min",
    "crumbs": [
      "Slides",
      "wgpu with rust"
    ]
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "Hi, this is a site where I store my tutorials and slides; you can try out the demos in demo sections and see the source code in the git repository.",
    "crumbs": [
      "About"
    ]
  }
]