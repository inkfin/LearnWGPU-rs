[
  {
    "objectID": "slides/sph_simulation.html#fluid-simulation",
    "href": "slides/sph_simulation.html#fluid-simulation",
    "title": "Smooth Particle Hydrodynamics with webgpu",
    "section": "Fluid Simulation",
    "text": "Fluid Simulation\nDifferent Types of SPH\n\nWCSPH (weakly compressed sph) ✅\nPCISPH (predictive-corrective incompressible sph)\nIISPH (implicit incompressible sph)\nDFSPH (divergence-free sph)\n\nIncompressible Navier-Stokes equation\n\\[\n\\begin{align}\n\\rho \\frac{Dv}{Dt} &= \\rho g - \\nabla p + \\mu \\nabla^2 v \\\\\n\\nabla \\cdot v &= 0\n\\end{align}\n\\]\nWhich basically means this:\n\\[\nma = f_{ext} + f_{pres} + f_{visc}\n\\]\nTurns into this:\n\\[\na = \\frac{f_{ext} + f_{pres} + f_{visc}}{V_j \\times \\rho_j}\n\\]\n\nHow to get the density?",
    "crumbs": [
      "Slides",
      "Smooth Particle Hydrodynamics with webgpu"
    ]
  },
  {
    "objectID": "slides/sph_simulation.html#kernel-functions",
    "href": "slides/sph_simulation.html#kernel-functions",
    "title": "Smooth Particle Hydrodynamics with webgpu",
    "section": "Kernel Functions",
    "text": "Kernel Functions\n\n\nimagine a probe…\n\n\nscreenshots taken from: taichi 10_fluid_lagrangian",
    "crumbs": [
      "Slides",
      "Smooth Particle Hydrodynamics with webgpu"
    ]
  },
  {
    "objectID": "slides/sph_simulation.html#compute-the-acceleration-for-particle",
    "href": "slides/sph_simulation.html#compute-the-acceleration-for-particle",
    "title": "Smooth Particle Hydrodynamics with webgpu",
    "section": "Compute the acceleration for particle",
    "text": "Compute the acceleration for particle\n\nfor \\(i\\) in particles:\n\nEvaluate density\n\n\n\\(\\rho_i = \\sum_j \\frac{m_j}{\\rho_j} \\rho_j W(r_i - r_j, h) = \\sum_j m_j W_{ij}\\)\n\n\nEvaluate non-pressure force: gravity, viscosity\n\n\n\\(g\\)\n\\(v\\nabla^2 v_i = v\\sum_jm_j\\frac{v_j-v_i}{\\rho_j}\\nabla^2 W_{ij}\\)\n\n\nEvaluate pressure gradient\n\n\n\\(-\\frac{1}{\\rho_i}\\nabla p_i = -\\sum_j m_j(\\frac{p_j}{\\rho^2_j} + \\frac{p_i}{\\rho^2_i})\\nabla W_{ij}\\)",
    "crumbs": [
      "Slides",
      "Smooth Particle Hydrodynamics with webgpu"
    ]
  },
  {
    "objectID": "slides/sph_simulation.html#boundary-problems",
    "href": "slides/sph_simulation.html#boundary-problems",
    "title": "Smooth Particle Hydrodynamics with webgpu",
    "section": "boundary problems",
    "text": "boundary problems\n\nfree surface\n\ndensity –&gt; 0\nclamp the minimum density\n\nsolid boundary\n\ndensity –&gt; 0\nparticles gather at the boundary\nCreate imagine particles outside boundaries",
    "crumbs": [
      "Slides",
      "Smooth Particle Hydrodynamics with webgpu"
    ]
  },
  {
    "objectID": "slides/sph_simulation.html#depth-texture",
    "href": "slides/sph_simulation.html#depth-texture",
    "title": "Smooth Particle Hydrodynamics with webgpu",
    "section": "Depth Texture",
    "text": "Depth Texture\nSmooth surface by filtering depth texture\nRender depth texture and copy it to textures for read & write",
    "crumbs": [
      "Slides",
      "Smooth Particle Hydrodynamics with webgpu"
    ]
  },
  {
    "objectID": "slides/sph_simulation.html#filter",
    "href": "slides/sph_simulation.html#filter",
    "title": "Smooth Particle Hydrodynamics with webgpu",
    "section": "Filter",
    "text": "Filter\nUse Bilateral filter since it won’t smooth depth.",
    "crumbs": [
      "Slides",
      "Smooth Particle Hydrodynamics with webgpu"
    ]
  },
  {
    "objectID": "slides/sph_simulation.html#pipeline",
    "href": "slides/sph_simulation.html#pipeline",
    "title": "Smooth Particle Hydrodynamics with webgpu",
    "section": "Pipeline",
    "text": "Pipeline\n  src\n  │   lib.rs\n  │   particle_system.rs\n  │   renderer.rs\n  |   ...\n  │\n  ├───particle_system\n  │       gpu_pass.rs\n  │       grid.rs\n  │       particles.rs\n  │       utils.rs\n  │\n  └───renderer\n          bind_group_layout_cache.rs\n          compute_pass_copy_depth.rs\n          compute_pass_depth_filter.rs\n          compute_pass_depth_filter_basic.rs\n          compute_pass_particle.rs\n          render_pass_depth.rs\n          render_pass_water.rs\nEach pass struct contains lots of objects… (buffer, bind_group_layout, bind_group, pipeline_layout, pipeline, encoder, pass)\nSharing objects requires passing references everywhere… sometimes through the whole call stack…",
    "crumbs": [
      "Slides",
      "Smooth Particle Hydrodynamics with webgpu"
    ]
  },
  {
    "objectID": "slides/sph_simulation.html#bitonic-sort-performance-test",
    "href": "slides/sph_simulation.html#bitonic-sort-performance-test",
    "title": "Smooth Particle Hydrodynamics with webgpu",
    "section": "Bitonic Sort Performance Test",
    "text": "Bitonic Sort Performance Test\nImplement parallel bitonic sort algorithms with Rust and Wgpu.\n\nsize = \\(2^{8}\\)\n\nCPU faster than GPU\n\n\n[2024-04-12T09:56:02Z INFO  bitonic_sort] Bitonic sort successful!\n[2024-04-12T09:56:02Z INFO  bitonic_sort] Initialization takes: 0.4548751s\n[2024-04-12T09:56:02Z INFO  bitonic_sort] Wgpu computation takes: 0.0055504s\n[2024-04-12T09:56:02Z INFO  bitonic_sort] Data transfer takes: 0.0001467s\n[2024-04-12T09:56:02Z INFO  bitonic_sort] CPU sorting takes: 0.000011s\n\nsize = \\(2^{18}\\)\n\nSimilar performance\n\n\n[2024-04-12T09:57:18Z INFO  bitonic_sort] Bitonic sort successful!\n[2024-04-12T09:57:18Z INFO  bitonic_sort] Initialization takes: 0.4637676s\n[2024-04-12T09:57:18Z INFO  bitonic_sort] Wgpu computation takes: 0.0214897s\n[2024-04-12T09:57:18Z INFO  bitonic_sort] Data transfer takes: 0.0005794s\n[2024-04-12T09:57:18Z INFO  bitonic_sort] CPU sorting takes: 0.0217035s\n\nsize = \\(2^{17}\\) (release mode)\n\nSimilar performance\n\n\n[2024-04-12T21:33:44Z INFO  bitonic_sort] Bitonic sort successful!\n[2024-04-12T21:33:44Z INFO  bitonic_sort] Initialization takes: 0.3913661s\n[2024-04-12T21:33:44Z INFO  bitonic_sort] Wgpu computation takes: 0.0090767s\n[2024-04-12T21:33:44Z INFO  bitonic_sort] Data transfer takes: 0.000544s\n[2024-04-12T21:33:44Z INFO  bitonic_sort] CPU sorting takes: 0.0098242s\n\nsize = \\(2^{25}\\)\n\nGPU faster than CPU\n\n\n[2024-04-12T09:53:07Z INFO  bitonic_sort] Bitonic sort successful!\n[2024-04-12T09:53:07Z INFO  bitonic_sort] Initialization takes: 0.9346608s\n[2024-04-12T09:53:07Z INFO  bitonic_sort] Wgpu computation takes: 0.1369619s\n[2024-04-12T09:53:07Z INFO  bitonic_sort] Data transfer takes: 0.9909169s\n[2024-04-12T09:53:07Z INFO  bitonic_sort] CPU sorting takes: 4.1491945s",
    "crumbs": [
      "Slides",
      "Smooth Particle Hydrodynamics with webgpu"
    ]
  },
  {
    "objectID": "slides/sph_simulation.html#credit",
    "href": "slides/sph_simulation.html#credit",
    "title": "Smooth Particle Hydrodynamics with webgpu",
    "section": "Credit",
    "text": "Credit\nSpecial thanks to:\n\nProfessor Tim McGraw, for teaching the lesson on Compute Shader and providing a helpful demo for reference.\nTaichiCourse01 for their lessons of Fluid Simulation. ppt\ntaichi_sph for providing guidance in the development process.\nNae Zhu for his introduction of a Screen Space Fluid Rendering method.",
    "crumbs": [
      "Slides",
      "Smooth Particle Hydrodynamics with webgpu"
    ]
  },
  {
    "objectID": "slides/intro.html",
    "href": "slides/intro.html",
    "title": "wgpu with rust",
    "section": "",
    "text": "40 pages\n\n\nWGPU is an implementation of WebGPU &gt; 5min\n\n\n\n\n10min\n\n\n\n\n\n5min\n\n\n\n\nbuffers, stuff with example code &gt; 20min\n\n\n\n\n10min"
  },
  {
    "objectID": "slides/intro.html#what-is-wgpu",
    "href": "slides/intro.html#what-is-wgpu",
    "title": "wgpu with rust",
    "section": "",
    "text": "WGPU is an implementation of WebGPU &gt; 5min"
  },
  {
    "objectID": "slides/intro.html#rust-in-10min",
    "href": "slides/intro.html#rust-in-10min",
    "title": "wgpu with rust",
    "section": "",
    "text": "10min"
  },
  {
    "objectID": "slides/intro.html#an-easy-wgsl-example",
    "href": "slides/intro.html#an-easy-wgsl-example",
    "title": "wgpu with rust",
    "section": "",
    "text": "5min"
  },
  {
    "objectID": "slides/intro.html#wgpu-pipeline",
    "href": "slides/intro.html#wgpu-pipeline",
    "title": "wgpu with rust",
    "section": "",
    "text": "buffers, stuff with example code &gt; 20min"
  },
  {
    "objectID": "slides/intro.html#example-demonstration",
    "href": "slides/intro.html#example-demonstration",
    "title": "wgpu with rust",
    "section": "",
    "text": "10min"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "Hi, this is a site where I store my tutorials and slides; you can try out the demos in demo sections and see the source code in the git repository.",
    "crumbs": [
      "About"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Home",
    "section": "",
    "text": "This is the home directory of 521-rs project.",
    "crumbs": [
      "Home"
    ]
  },
  {
    "objectID": "slides/introduction.html#what-is-webgpu",
    "href": "slides/introduction.html#what-is-webgpu",
    "title": "WGPU with Rust in 50min",
    "section": "What is WebGPU?",
    "text": "What is WebGPU?\n\nWebGPU is the next generation of WebGL and a cross-platform API.\nBackends: browser webgpu, vulkan, DX12, metal…\nImplementations\n\nwgpu for rust\nwgpu-native for c++\ngoogle dawn implementation in chromium\n\n\n\n\n\n\n\n\n\n\n\nFigure 1: wgpu github page\n\n\n\n\n\n\n\n\n\n\n\nFigure 2: wgpu-native github page\n\n\n\n\n\n\n\n\nmore universal\nmultiple backends, including Vulkan, webgpu",
    "crumbs": [
      "Slides",
      "WGPU with Rust in 50min"
    ]
  },
  {
    "objectID": "slides/introduction.html#learn-webgpu",
    "href": "slides/introduction.html#learn-webgpu",
    "title": "WGPU with Rust in 50min",
    "section": "Learn WebGPU",
    "text": "Learn WebGPU\n\nwebgpu fundamentals tutorial",
    "crumbs": [
      "Slides",
      "WGPU with Rust in 50min"
    ]
  },
  {
    "objectID": "slides/introduction.html#webassembly",
    "href": "slides/introduction.html#webassembly",
    "title": "WGPU with Rust in 50min",
    "section": "WebAssembly",
    "text": "WebAssembly\n\n\n\nWasm is designed as a portable compilation target for programming languages, enabling deployment on the web for client and server applications.\n\nwebassembly.org",
    "crumbs": [
      "Slides",
      "WGPU with Rust in 50min"
    ]
  },
  {
    "objectID": "slides/introduction.html#meet-rust",
    "href": "slides/introduction.html#meet-rust",
    "title": "WGPU with Rust in 50min",
    "section": "Meet Rust ",
    "text": "Meet Rust \n\nRust is a modern programming language that balances high-level ergonomics and low-level control. 1\n\nmemory safety\nzero-cost abstraction\npowerful toolsets\n\n\nThe book: https://doc.rust-lang.org/book/",
    "crumbs": [
      "Slides",
      "WGPU with Rust in 50min"
    ]
  },
  {
    "objectID": "slides/introduction.html#to-get-started",
    "href": "slides/introduction.html#to-get-started",
    "title": "WGPU with Rust in 50min",
    "section": "To get started",
    "text": "To get started\n\nInstall rustup (Instructions)\n\nrustc --version\n# will gives you something like: \n#   rustc 1.75.0 (82e1608df 2023-12-21)\n\nCargo is the rust’s official package manager\n\n# cd into the project root directory\ncargo run --release\n\nInstall wasm-pack (Instructions)\n\nwasm-pack build --target web",
    "crumbs": [
      "Slides",
      "WGPU with Rust in 50min"
    ]
  },
  {
    "objectID": "slides/introduction.html#comparing-to-opengl-c",
    "href": "slides/introduction.html#comparing-to-opengl-c",
    "title": "WGPU with Rust in 50min",
    "section": "Comparing to OpenGL & C++…",
    "text": "Comparing to OpenGL & C++…\n\n\nC++\n\nmore flexible with raw pointer\nuse a lot of classes, interfaces\nthe language of lots of game engines: Source, Unreal Engine\nglew + glfw + imgui\n\n\nRust\n\nbetter error handle & easier async\nno Class, use struct & traits\nnew experimental game engines under development: Bevy, Fyrox\nwgpu + winit + egui",
    "crumbs": [
      "Slides",
      "WGPU with Rust in 50min"
    ]
  },
  {
    "objectID": "slides/introduction.html#hello-world",
    "href": "slides/introduction.html#hello-world",
    "title": "WGPU with Rust in 50min",
    "section": "Hello world!",
    "text": "Hello world!\nFirst, create a rust project using cargo\ncargo new hello-world\nUse your favorite editor and edit the src/main.rs:\nfn main() {\n    let name = \"ink\";\n    println!(\"Hello, world! from {:?}\", name)\n}\nTo run the code:\ncargo run\nThe result should be:\nlet name = \"ink\";\nprintln!(\"Hello, world! from {:?}\", name);",
    "crumbs": [
      "Slides",
      "WGPU with Rust in 50min"
    ]
  },
  {
    "objectID": "slides/introduction.html#great-now-the-wgpu-examples",
    "href": "slides/introduction.html#great-now-the-wgpu-examples",
    "title": "WGPU with Rust in 50min",
    "section": "Great! Now the wgpu examples",
    "text": "Great! Now the wgpu examples\n\nThe example git repository: link\n\n# we do a shallow clone\ngit clone https://github.com/inkfin/LearnWGPU-rs.git --depth=1 \nSee the README.md for build instructions, or you can find the pre-build examples in the DEMO part on my GitHub page.\n\n\nThe official repository example (some of v0.18 examples are broken with current API): wgpu v0.18 examples",
    "crumbs": [
      "Slides",
      "WGPU with Rust in 50min"
    ]
  },
  {
    "objectID": "slides/introduction.html#take-a-sip-of-coffee..",
    "href": "slides/introduction.html#take-a-sip-of-coffee..",
    "title": "WGPU with Rust in 50min",
    "section": "Take a sip of coffee..",
    "text": "Take a sip of coffee..\n\nLet’s take a short break. Feel free to stretch, refill your coffee, and prepare for our next segment on integrating Rust with wgpu.\nHave any questions so far?",
    "crumbs": [
      "Slides",
      "WGPU with Rust in 50min"
    ]
  },
  {
    "objectID": "slides/introduction.html#what-we-have-learned-from-521-about-opengl",
    "href": "slides/introduction.html#what-we-have-learned-from-521-about-opengl",
    "title": "WGPU with Rust in 50min",
    "section": "What we have learned from 521 about OpenGL",
    "text": "What we have learned from 521 about OpenGL\n\n\nEverything is in a giant state machine\nglCommands depend on context\nObjects are generated and returned as IDs\nNeed to bind objects to the current target before performing any actions\nNo abstraction for render passes and render pipeline\n\nNeed developers to create their own pipeline by setting things in the context",
    "crumbs": [
      "Slides",
      "WGPU with Rust in 50min"
    ]
  },
  {
    "objectID": "slides/introduction.html#opengl-vulkan-webgpu",
    "href": "slides/introduction.html#opengl-vulkan-webgpu",
    "title": "WGPU with Rust in 50min",
    "section": "OpenGL Vulkan WebGPU",
    "text": "OpenGL Vulkan WebGPU\nOpenGL\n\n\n~80 lines\n\n\nVulkan\n\n\n~400 lines\n\n\nWebGPU\n\n\nonly 175 lines1\n\n\nhello_triangle",
    "crumbs": [
      "Slides",
      "WGPU with Rust in 50min"
    ]
  },
  {
    "objectID": "slides/introduction.html#wgpu-pipeline-1",
    "href": "slides/introduction.html#wgpu-pipeline-1",
    "title": "WGPU with Rust in 50min",
    "section": "Wgpu pipeline",
    "text": "Wgpu pipeline\n\nBetter abstractions (simillar to vulkan)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nInstance\n\n\n\nSurface\n\n\n\nAdapter\n\n\n\nDevice\n\n\n\nQueue\n\n\n\n\n\n\n\n\n\n\nInstance: a handle to our GPU, first thing ever created ([GPU] in WebGPU)\nSurface: a platform-specific surface (e.g., a window) onto which rendered images may be presented ([GPUCanvasContext] in WebGPU)\n\nCareful: need to live as long as the window (canvas)\n\nAdapter: Handle to a physical graphics and/or compute device ([GPUAdapter] in WebGPU)",
    "crumbs": [
      "Slides",
      "WGPU with Rust in 50min"
    ]
  },
  {
    "objectID": "slides/introduction.html#cont.",
    "href": "slides/introduction.html#cont.",
    "title": "WGPU with Rust in 50min",
    "section": "Cont.",
    "text": "Cont.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nInstance\n\n\n\nSurface\n\n\n\nAdapter\n\n\n\nDevice\n\n\n\nQueue\n\n\n\n\n\n\n\n\n\n\nDevice: Open connection to a graphics and/or compute device. ([GPUDevice] in WebGPU)\n\nResponsible for the creation of most rendering and compute resources. These are then used in commands, which are submitted to a [Queue].\n\nQueue: Handle to a command queue on a device ([GPUQueue] in WebGPU)\n\nexecutes recorded [CommandBuffer] objects and provides convenience methods for writing to buffers and textures.",
    "crumbs": [
      "Slides",
      "WGPU with Rust in 50min"
    ]
  },
  {
    "objectID": "slides/introduction.html#the-structure-of-a-renderpass",
    "href": "slides/introduction.html#the-structure-of-a-renderpass",
    "title": "WGPU with Rust in 50min",
    "section": "The Structure of a RenderPass",
    "text": "The Structure of a RenderPass\n\n\n\n\n\n\n\n\n\nPipelineLayout\n\n\n\nBindgroups\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nset_vertex_buffer\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nset_pipeline\n\n\n\n\n\n\n\n\n\n\n\nUniformBindGroupLayoutTextureBindGroupLayoutStorageBindGroupLayout…\n\n\n\nRenderPipelineLayout\n\n\n\nFragmentState\n\n\n\nFragmentShader\n\n\n\nVertexState\n\n\n\nVertexShader\n\n\n\nVertexBufferLayout\n\n\n\nBindgroup 0Bindgroup 1Bindgroup 2…\n\n\n\nBindGroupLayout\n\n\n\nBuffers\n\n\n\nTexture\n\n\n\nRenderPass\n\n\n\nRenderPipeline",
    "crumbs": [
      "Slides",
      "WGPU with Rust in 50min"
    ]
  },
  {
    "objectID": "slides/introduction.html#renderpass",
    "href": "slides/introduction.html#renderpass",
    "title": "WGPU with Rust in 50min",
    "section": "RenderPass",
    "text": "RenderPass\nThis is the vulkan || webgpu abstraction of rendering procedure.\nEncoder & Renderpass object will return a CommandBuffer, a complete sequence of commands that may be submitted to a command queue\n\n\nBindGroups (maps Buffers & Textures to bind points)\nVertexBufferLayout (VertexAttributes)\nShader",
    "crumbs": [
      "Slides",
      "WGPU with Rust in 50min"
    ]
  },
  {
    "objectID": "slides/introduction.html#renderpass-1",
    "href": "slides/introduction.html#renderpass-1",
    "title": "WGPU with Rust in 50min",
    "section": "RenderPass",
    "text": "RenderPass\nlet mut encoder = device.create_command_encoder(...);\n{\n  // force out of scope since render_pass can't live longer than encoder\n  let mut render_pass = encoder.begin_render_pass(\n    &wgpu::RenderPassDescriptor {\n      label: Some(\"Render Pass\"),\n      color_attachments: ...,\n      depth_stencil_attachment: ...,\n      occlusion_query_set: None,\n      timestamp_writes: None,\n  });\n  render_pass.set_pipeline(...);\n  render_pass.set_vertex_buffer(...);\n  render_pass.set_index_buffer(...);\n  render_pass.set_bind_group(...);\n  render_pass.draw_indexed();\n}\nqueue.submit(vec![encoder.finish()]);\n\n\nsource code: example_cube/src/lib.rs:481",
    "crumbs": [
      "Slides",
      "WGPU with Rust in 50min"
    ]
  },
  {
    "objectID": "slides/introduction.html#renderpass-2",
    "href": "slides/introduction.html#renderpass-2",
    "title": "WGPU with Rust in 50min",
    "section": "RenderPass",
    "text": "RenderPass\nlet mut encoder = device.create_command_encoder(...);\n{\n  // force out of scope since render_pass can't live longer than encoder\n  let mut render_pass = encoder.begin_render_pass(\n    &wgpu::RenderPassDescriptor {\n      label: Some(\"Render Pass\"),\n      color_attachments: ...,\n      depth_stencil_attachment: ...,\n      occlusion_query_set: None,\n      timestamp_writes: None,\n  });\n  render_pass.set_pipeline(...);\n  render_pass.set_vertex_buffer(...);\n  render_pass.set_index_buffer(...);\n  render_pass.set_bind_group(...);\n  render_pass.draw_indexed();\n}\nqueue.submit(vec![encoder.finish()]);\n\n\nsource code: example_cube/src/lib.rs:481",
    "crumbs": [
      "Slides",
      "WGPU with Rust in 50min"
    ]
  },
  {
    "objectID": "slides/introduction.html#renderpass-3",
    "href": "slides/introduction.html#renderpass-3",
    "title": "WGPU with Rust in 50min",
    "section": "RenderPass",
    "text": "RenderPass\nlet mut encoder = device.create_command_encoder(...);\n{\n  // force out of scope since render_pass can't live longer than encoder\n  let mut render_pass = encoder.begin_render_pass(\n    &wgpu::RenderPassDescriptor {\n      label: Some(\"Render Pass\"),\n      color_attachments: ...,\n      depth_stencil_attachment: ...,\n      occlusion_query_set: None,\n      timestamp_writes: None,\n  });\n  render_pass.set_pipeline(...);\n  render_pass.set_vertex_buffer(...);\n  render_pass.set_index_buffer(...);\n  render_pass.set_bind_group(...);\n  render_pass.draw_indexed();\n}\nqueue.submit(vec![encoder.finish()]);\n\n\nsource code: example_cube/src/lib.rs:481",
    "crumbs": [
      "Slides",
      "WGPU with Rust in 50min"
    ]
  },
  {
    "objectID": "slides/introduction.html#renderpipeline",
    "href": "slides/introduction.html#renderpipeline",
    "title": "WGPU with Rust in 50min",
    "section": "RenderPipeline",
    "text": "RenderPipeline\n\nThe collection of resources and states.\n\n\n\nShader\nBuffers (VertexBuffers, UniformBuffers)\nprimitive state\ndepth_stencil\n…",
    "crumbs": [
      "Slides",
      "WGPU with Rust in 50min"
    ]
  },
  {
    "objectID": "slides/introduction.html#renderpipeline-1",
    "href": "slides/introduction.html#renderpipeline-1",
    "title": "WGPU with Rust in 50min",
    "section": "RenderPipeline",
    "text": "RenderPipeline\n\nRenderPipelineLayout\n/// A `PipelineLayout` object describes the available binding groups of a pipeline.\n/// It can be created with [`Device::create_pipeline_layout`].\nRenderPipeline\n/// A `RenderPipeline` object represents a graphics pipeline and its stages, bindings, vertex\n/// buffers and targets. It can be created with [`Device::create_render_pipeline`].",
    "crumbs": [
      "Slides",
      "WGPU with Rust in 50min"
    ]
  },
  {
    "objectID": "slides/introduction.html#wgpu-buffers",
    "href": "slides/introduction.html#wgpu-buffers",
    "title": "WGPU with Rust in 50min",
    "section": "Wgpu buffers",
    "text": "Wgpu buffers\n\nBuffer is GPU-accessible buffer 1\n\nBufferSlice: wgpu side buffer util used to set range of buffers\n\nIt uses BufferInitDescriptor for initialization\n\n\n\nsee example_cube/src/lib.rs:275\n[WebGPU GPUBuffer]",
    "crumbs": [
      "Slides",
      "WGPU with Rust in 50min"
    ]
  },
  {
    "objectID": "slides/introduction.html#vertexbuffer",
    "href": "slides/introduction.html#vertexbuffer",
    "title": "WGPU with Rust in 50min",
    "section": "VertexBuffer",
    "text": "VertexBuffer\nCreate a buffer and init with raw data.\nlet vertex_buffer = device.create_buffer_init(\n  &wgpu::util::BufferInitDescriptor {\n    label: Some(\"Vertex Buffer\"),\n    contents: bytemuck::cast_slice(&vertices),\n    usage: wgpu::BufferUsages::VERTEX,\n});\n\ncontents: plain data\nusage: buffer usage",
    "crumbs": [
      "Slides",
      "WGPU with Rust in 50min"
    ]
  },
  {
    "objectID": "slides/introduction.html#vertexbuffer-1",
    "href": "slides/introduction.html#vertexbuffer-1",
    "title": "WGPU with Rust in 50min",
    "section": "VertexBuffer",
    "text": "VertexBuffer\nSet vertex buffer before the draw call in the render pass.\nrender_pass.set_vertex_buffer(slot, vertex_buffer.slice(..));\n\nslot: index in VertexState::buffers\n\n  // in render_pipeline:\n  wgpu::VertexState {\n      module: &shader,\n      entry_point: \"vs_main\",\n      buffers: &[model::ModelVertex::desc(), InstanceRaw::desc()],\n  },\nLayouts and buffers are set separately!\n\nBufferSlice: wgpu rust side buffer slice\n\neasy to use (no starts or offsets)",
    "crumbs": [
      "Slides",
      "WGPU with Rust in 50min"
    ]
  },
  {
    "objectID": "slides/introduction.html#cont.-1",
    "href": "slides/introduction.html#cont.-1",
    "title": "WGPU with Rust in 50min",
    "section": "Cont.",
    "text": "Cont.\n// in desc():\nwgpu::VertexBufferLayout {\n    array_stride: mem::size_of::&lt;ModelVertex&gt;() as wgpu::BufferAddress,\n    step_mode: wgpu::VertexStepMode::Vertex,\n    attributes: &[\n        wgpu::VertexAttribute {\n            format: wgpu::VertexFormat::Float32x3,\n            offset: 0,\n            shader_location: 0,\n        },\n        wgpu::VertexAttribute {\n            format: wgpu::VertexFormat::Float32x2,\n            offset: mem::size_of::&lt;[f32; 3]&gt;() as wgpu::BufferAddress,\n            shader_location: 1,\n        },\n        wgpu::VertexAttribute {\n            format: wgpu::VertexFormat::Float32x3,\n            offset: mem::size_of::&lt;[f32; 5]&gt;() as wgpu::BufferAddress,\n            shader_location: 2,\n        },\n    ],\n}",
    "crumbs": [
      "Slides",
      "WGPU with Rust in 50min"
    ]
  },
  {
    "objectID": "slides/introduction.html#uniform-buffers",
    "href": "slides/introduction.html#uniform-buffers",
    "title": "WGPU with Rust in 50min",
    "section": "Uniform Buffers",
    "text": "Uniform Buffers\n\nData that is uniform in the same render pass\n\nread-only in shader\ncan be updated (frequently) in client code\n\nusage: wgpu::BufferUsages::UNIFORM | wgpu::BufferUsages::COPY_DST,\nComparing to OpenGL:\nglBufferData(GL_UNIFORM_BUFFER, size, NULL, GL_DYNAMIC_DRAW);",
    "crumbs": [
      "Slides",
      "WGPU with Rust in 50min"
    ]
  },
  {
    "objectID": "slides/introduction.html#cont.-2",
    "href": "slides/introduction.html#cont.-2",
    "title": "WGPU with Rust in 50min",
    "section": "Cont.",
    "text": "Cont.\n\nBindgroupLayout\n\ndefines how shader treats the buffer\n\nwgpu::BindGroupLayoutEntry {\n  binding: 0,\n  visibility: wgpu::ShaderStages::VERTEX,\n  ty: wgpu::BindingType::Buffer {\n      ty: wgpu::BufferBindingType::Uniform,\n      has_dynamic_offset: false,\n      min_binding_size: None,\n  },\n  count: None,\n}\n\n\n\nsource code: example_cube/src/lib.rs:282",
    "crumbs": [
      "Slides",
      "WGPU with Rust in 50min"
    ]
  },
  {
    "objectID": "slides/introduction.html#textures",
    "href": "slides/introduction.html#textures",
    "title": "WGPU with Rust in 50min",
    "section": "Textures",
    "text": "Textures\n\nBindgroupLayout\n\nthe wgpu shader treats Buffers and Textures in the same way – bindgroup\n\nOpenGL: treats sampler*d as a uniform\n\nenable texture unit\nbind texture\ncall glUniform* to set sampler in the shader\n\nWGPU: set bindgroup where TextureView and Sampler are specifies saperately",
    "crumbs": [
      "Slides",
      "WGPU with Rust in 50min"
    ]
  },
  {
    "objectID": "slides/introduction.html#cont.-3",
    "href": "slides/introduction.html#cont.-3",
    "title": "WGPU with Rust in 50min",
    "section": "Cont.",
    "text": "Cont.\nwgpu::BindGroupLayoutDescriptor {\n    entries: &[\n        wgpu::BindGroupLayoutEntry {\n            binding: 0,\n            visibility: wgpu::ShaderStages::FRAGMENT,\n            ty: wgpu::BindingType::Texture {\n                multisampled: false,\n                view_dimension: wgpu::TextureViewDimension::D2,\n                sample_type: wgpu::TextureSampleType::Float { filterable: true },\n            },\n            count: None,\n        },\n        wgpu::BindGroupLayoutEntry {\n            binding: 1,\n            visibility: wgpu::ShaderStages::FRAGMENT,\n            ty: wgpu::BindingType::Sampler(wgpu::SamplerBindingType::Filtering),\n            count: None,\n        },\n    ],\n    label: Some(\"texture_bind_group_layout\"),\n}",
    "crumbs": [
      "Slides",
      "WGPU with Rust in 50min"
    ]
  },
  {
    "objectID": "slides/introduction.html#cont.-4",
    "href": "slides/introduction.html#cont.-4",
    "title": "WGPU with Rust in 50min",
    "section": "Cont.",
    "text": "Cont.\nlet diffuse_bind_group = device.create_bind_group(\n    &wgpu::BindGroupDescriptor {\n        layout: &texture_bind_group_layout,\n        entries: &[\n            wgpu::BindGroupEntry {\n                binding: 0,\n                resource: wgpu::BindingResource::TextureView(\n                    &diffuse_texture.view),\n            },\n            wgpu::BindGroupEntry {\n                binding: 1,\n                resource: wgpu::BindingResource::Sampler(\n                    &diffuse_texture.sampler),\n            },\n        ],\n        label: Some(\"diffuse_bind_group\"),\n});\n\n\nsource code: example_cube/src/lib.rs:208,233",
    "crumbs": [
      "Slides",
      "WGPU with Rust in 50min"
    ]
  },
  {
    "objectID": "slides/introduction.html#bindgroup",
    "href": "slides/introduction.html#bindgroup",
    "title": "WGPU with Rust in 50min",
    "section": "BindGroup",
    "text": "BindGroup\n\nBindGroupLayout\n/// Handle to a binding group layout.\n///\n/// A `BindGroupLayout` is a handle to the GPU-side layout of a binding group. It can be used to\n/// create a [`BindGroupDescriptor`] object, which in turn can be used to create a [`BindGroup`]\n/// object with [`Device::create_bind_group`]. A series of `BindGroupLayout`s can also be used to\n/// create a [`PipelineLayoutDescriptor`], which can be used to create a [`PipelineLayout`].\n///\n/// It can be created with [`Device::create_bind_group_layout`].\n///\n/// Corresponds to [WebGPU `GPUBindGroupLayout`](\n/// https://gpuweb.github.io/gpuweb/#gpubindgrouplayout).",
    "crumbs": [
      "Slides",
      "WGPU with Rust in 50min"
    ]
  },
  {
    "objectID": "slides/introduction.html#bindgroup-1",
    "href": "slides/introduction.html#bindgroup-1",
    "title": "WGPU with Rust in 50min",
    "section": "BindGroup",
    "text": "BindGroup\n\nBindGroup\n/// Handle to a binding group.\n///\n/// A `BindGroup` represents the set of resources bound to the bindings described by a\n/// [`BindGroupLayout`]. It can be created with [`Device::create_bind_group`]. A `BindGroup` can\n/// be bound to a particular [`RenderPass`] with [`RenderPass::set_bind_group`], or to a\n/// [`ComputePass`] with [`ComputePass::set_bind_group`].\n///\n/// Corresponds to [WebGPU `GPUBindGroup`](https://gpuweb.github.io/gpuweb/#gpubindgroup).",
    "crumbs": [
      "Slides",
      "WGPU with Rust in 50min"
    ]
  },
  {
    "objectID": "slides/introduction.html#bindgroup-in-wgsl",
    "href": "slides/introduction.html#bindgroup-in-wgsl",
    "title": "WGPU with Rust in 50min",
    "section": "BindGroup in WGSL",
    "text": "BindGroup in WGSL\n\nUniform\n\nstruct CameraUniform {\n    view_proj: mat4x4&lt;f32&gt;,\n};\n\n@group(1) @binding(0)\nvar&lt;uniform&gt; camera: CameraUniform;\n\nTexture\n\n@group(0) @binding(0)\nvar t_diffuse: texture_2d&lt;f32&gt;;\n@group(0) @binding(1)\nvar s_diffuse: sampler;",
    "crumbs": [
      "Slides",
      "WGPU with Rust in 50min"
    ]
  },
  {
    "objectID": "slides/introduction.html#section",
    "href": "slides/introduction.html#section",
    "title": "WGPU with Rust in 50min",
    "section": "",
    "text": "WGPU is excellent!",
    "crumbs": [
      "Slides",
      "WGPU with Rust in 50min"
    ]
  },
  {
    "objectID": "slides/introduction.html#section-1",
    "href": "slides/introduction.html#section-1",
    "title": "WGPU with Rust in 50min",
    "section": "",
    "text": "WGPU is excellent!\n\nExcept for WGSL… link",
    "crumbs": [
      "Slides",
      "WGPU with Rust in 50min"
    ]
  },
  {
    "objectID": "slides/introduction.html#yes-you-dont-need-to-learn-wgsl",
    "href": "slides/introduction.html#yes-you-dont-need-to-learn-wgsl",
    "title": "WGPU with Rust in 50min",
    "section": "Yes, you don’t need to learn WGSL!",
    "text": "Yes, you don’t need to learn WGSL!\nThanks to Naga\n\n\n\nYou only need to learn WGSL",
    "crumbs": [
      "Slides",
      "WGPU with Rust in 50min"
    ]
  },
  {
    "objectID": "slides/introduction.html#supported-front-ends",
    "href": "slides/introduction.html#supported-front-ends",
    "title": "WGPU with Rust in 50min",
    "section": "Supported Front-ends",
    "text": "Supported Front-ends\ncurrent support\n\n\nSPIR-V first class support\nGLSL has many limitations (440+ & Vulkan semantics only)\nuniform sampler2D mySampler;\nuniform texture2D myTexture;\n// == naga ==&gt;\n@group(0) @binding(0) var mySampler: sampler;\n@group(0) @binding(1) var myTexture: texture_2d&lt;f32&gt;;\nHLSL/GLSL/MSL -&gt; SPIRV -&gt; WGSL -&gt; SPIRV -&gt; [platform native]\n\nWhat a journey!",
    "crumbs": [
      "Slides",
      "WGPU with Rust in 50min"
    ]
  },
  {
    "objectID": "slides/introduction.html#wgsl-types",
    "href": "slides/introduction.html#wgsl-types",
    "title": "WGPU with Rust in 50min",
    "section": "WGSL types",
    "text": "WGSL types\n\n\n\nbasic types\n\ni32, u32, f32, bool\n\nbuiltins\n\n@builtin(vertex_index), @builtin(position)\n\nvectors\n\nvec2f === vec2&lt;f32&gt;\nvec3u === vec3&lt;u32&gt;\nvec4i === vec4&lt;i32&gt;\nconstructors\n\nmatrices\n\nmat2x3&lt;f32&gt; === mat2x3f (row x column)\ncolumn major\nconstructors\n\n\n\n\nfixed-size arrays\n\narray&lt;f32,5&gt;, c must be const-declared.\n\nruntime-sized arrays\n\ncan only be used with storage buffer resources.\n@group(0) @binding(0) var&lt;storage&gt; weights: array&lt;f32&gt;;\nUse the arrayLength() builtin function to get the element count.\n\nStructures\nAutomic Types\nPointers (What?)",
    "crumbs": [
      "Slides",
      "WGPU with Rust in 50min"
    ]
  },
  {
    "objectID": "slides/introduction.html#wgsl-simple-example",
    "href": "slides/introduction.html#wgsl-simple-example",
    "title": "WGPU with Rust in 50min",
    "section": "WGSL simple example 1",
    "text": "WGSL simple example 1\nstruct VertexOutput {\n    @builtin(position) clip_position: vec4&lt;f32&gt;,\n};\n\n@vertex\nfn vs_main(\n    @builtin(vertex_index) in_vertex_index: u32,\n) -&gt; VertexOutput {\n    var out: VertexOutput;\n    let x = f32(1 - i32(in_vertex_index)) * 0.5;\n    let y = f32(i32(in_vertex_index & 1u) * 2 - 1) * 0.5;\n    out.clip_position = vec4&lt;f32&gt;(x, y, 0.0, 1.0);\n    return out;\n}\n\n@fragment\nfn fs_main(in: VertexOutput) -&gt; @location(0) vec4&lt;f32&gt; {\n    return vec4&lt;f32&gt;(0.3, 0.2, 0.1, 1.0);\n}\nlearn-wgpu: tutorial3",
    "crumbs": [
      "Slides",
      "WGPU with Rust in 50min"
    ]
  },
  {
    "objectID": "slides/introduction.html#wgsl-online-demos",
    "href": "slides/introduction.html#wgsl-online-demos",
    "title": "WGPU with Rust in 50min",
    "section": "WGSL online demos",
    "text": "WGSL online demos\nonline tutorial & playground\nonline editor",
    "crumbs": [
      "Slides",
      "WGPU with Rust in 50min"
    ]
  },
  {
    "objectID": "slides/introduction.html#structure-of-compute-pass",
    "href": "slides/introduction.html#structure-of-compute-pass",
    "title": "WGPU with Rust in 50min",
    "section": "Structure of Compute Pass",
    "text": "Structure of Compute Pass\n\n\n\n\n\n\n\n\n\nBindgroups\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nset_bindgroup\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nset_pipeline\n\n\n\nBindgroup 0Bindgroup 1Bindgroup 2…\n\n\n\nBindGroupLayout\n\n\n\nBuffers\n\n\n\nTexture\n\n\n\nBindGroupLayouts\n\n\n\nPipelineLayout\n\n\n\nComputePass\n\n\n\nComputePipeline\n\n\n\nShader",
    "crumbs": [
      "Slides",
      "WGPU with Rust in 50min"
    ]
  },
  {
    "objectID": "slides/introduction.html#compute-pass",
    "href": "slides/introduction.html#compute-pass",
    "title": "WGPU with Rust in 50min",
    "section": "Compute Pass",
    "text": "Compute Pass\n\nNumber of cells to run, the (x,y,z) size of item being processed\n\ncompute_pass.dispatch_workgroups(numbers.len() as u32, 1, 1);\n\nin each cell:\n\n@compute\n@workgroup_size(2, 1, 1)\nfn main(\n  @builtin(local_invocation_id) lid: vec3&lt;u32&gt;, \n  @builtin(workgroup_id) wid: vec3&lt;u32&gt;\n  ) {\n    if lid.x == 0u {\n        a[wid.x] += 1;\n    } else if lid.x == 1u {\n        b[wid.x] += 1;\n    }\n}",
    "crumbs": [
      "Slides",
      "WGPU with Rust in 50min"
    ]
  },
  {
    "objectID": "slides/introduction.html#workgroups-builtins",
    "href": "slides/introduction.html#workgroups-builtins",
    "title": "WGPU with Rust in 50min",
    "section": "Workgroups builtins",
    "text": "Workgroups builtins\n@builtin(workgroup_id)            workgroup_id : vec3&lt;u32&gt;,\n@builtin(local_invocation_id)     local_invocation_id : vec3&lt;u32&gt;,\n@builtin(global_invocation_id)    global_invocation_id : vec3&lt;u32&gt;,\n@builtin(local_invocation_index)  local_invocation_index: u32,\n@builtin(num_workgroups)          num_workgroups: vec3&lt;u32&gt;",
    "crumbs": [
      "Slides",
      "WGPU with Rust in 50min"
    ]
  },
  {
    "objectID": "slides/introduction.html#workgroups-shared-memories",
    "href": "slides/introduction.html#workgroups-shared-memories",
    "title": "WGPU with Rust in 50min",
    "section": "Workgroups shared memories",
    "text": "Workgroups shared memories\ntour-of-wgsl\n\nlike shared memories in OpenGL\nbarriers: workgroupBarrier()\nUnlike OpenGL, wgpu encourages computation done within one workgroup. It limits access by using the address space [var&lt;workgroup&gt;].\n\n// Create zero-initialized workgroup shared data\nconst workgroup_len : u32 = 8;\nvar&lt;workgroup&gt; workgroup_data: array&lt;u32, workgroup_len&gt;;\n\n@group(0) @binding(0) var&lt;storage, read&gt; input_data: array&lt;u32&gt;;\n@group(0) @binding(1) var&lt;storage, read_write&gt; output_data: u32;\n\n// Our workgroup will execute workgroup_len invocations of the shader\n@compute @workgroup_size(workgroup_len, 1, 1)\nfn computeMain(@builtin(local_invocation_id) local_id: vec3&lt;u32&gt;) {\n  // Each invocation will populate the shared workgroup data from the input data\n  workgroup_data[local_id.x] = input_data[local_id.x];\n\n  // Wait for each invocation to populate their region of local data\n  workgroupBarrier();\n\n  // Get the sum of the elements in the array\n  // Input Data:    [0,  1,  2,  3,   4,  5,  6,  7]\n  // Loop Pass 1:   [1,  5,  9,  13,  4,  5,  6,  7]\n  // Loop Pass 2:   [6,  22, 9,  13,  4,  5,  6,  7]\n  for (var current_size = workgroup_len / 2; current_size &gt;= 1; current_size /= 2) {\n    var sum: u32 = 0;\n    if (local_id.x &lt; current_size) {\n      // Read current values from workgroup_data\n      sum = workgroup_data[local_id.x * 2] + workgroup_data[local_id.x * 2 + 1];\n    }\n    // Wait until all invocations have finished reading from workgroup_data, and have calculated their respective sums\n    workgroupBarrier();\n    if (local_id.x &lt; current_size) {\n      workgroup_data[local_id.x] = sum;\n    }\n    // Wait for each invocation to finish one iteration of the loop, and to have finished writing to workgroup_data\n    workgroupBarrier();\n  }\n\n  // Write the sum to the output\n  if (local_id.x == 0) {\n    output_data = workgroup_data[0];\n  }\n}",
    "crumbs": [
      "Slides",
      "WGPU with Rust in 50min"
    ]
  },
  {
    "objectID": "slides/introduction.html#storage-buffers",
    "href": "slides/introduction.html#storage-buffers",
    "title": "WGPU with Rust in 50min",
    "section": "Storage buffers",
    "text": "Storage buffers\n@group(0) @binding(0) var&lt;storage, read_write&gt; v_indices: array&lt;u32&gt;;\n@group(1) @binding(0) var texture: texture_storage_2d&lt;rgba8unorm, write&gt;;\n// in fn main():\ntextureStore(texture, location, value);\n\nvar&lt;storage, S&gt;\n\nS denotes read-write access type\n\n\n// in BufferInitDescriptor:\nusage: wgpu::BufferUsages::STORAGE\n    | wgpu::BufferUsages::COPY_DST\n    | wgpu::BufferUsages::COPY_SRC,\n\n\nwgpu v0.18 workgroup examples\nWebGPU Compute Shader Basics",
    "crumbs": [
      "Slides",
      "WGPU with Rust in 50min"
    ]
  },
  {
    "objectID": "slides/introduction.html#compute_example",
    "href": "slides/introduction.html#compute_example",
    "title": "WGPU with Rust in 50min",
    "section": "compute_example",
    "text": "compute_example\nIf you have cloned the project, go to ./compute_example/\nor download compute_example.zip",
    "crumbs": [
      "Slides",
      "WGPU with Rust in 50min"
    ]
  }
]